/* tslint:disable */
/* eslint-disable */
/**
 * Auctionator EVM
 * The Auctionator EVM API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuctionEntity
 */
export interface AuctionEntity {
    /**
     * Name of the auction
     * @type {string}
     * @memberof AuctionEntity
     */
    'name': string;
    /**
     * Description of the auction
     * @type {string}
     * @memberof AuctionEntity
     */
    'description': string;
    /**
     * Start date of the auction
     * @type {string}
     * @memberof AuctionEntity
     */
    'startDate': string;
    /**
     * Duration of the auction (in seconds)
     * @type {number}
     * @memberof AuctionEntity
     */
    'duration': number;
    /**
     * Extension of the auction (in seconds)
     * @type {number}
     * @memberof AuctionEntity
     */
    'extension': number;
    /**
     * Start price of the auction
     * @type {number}
     * @memberof AuctionEntity
     */
    'startPrice': number;
    /**
     * Current price of the auction
     * @type {number}
     * @memberof AuctionEntity
     */
    'currentPrice': number;
    /**
     * Remaining time of the auction (in seconds)
     * @type {number}
     * @memberof AuctionEntity
     */
    'remainingTime': number;
    /**
     * Auction status
     * @type {string}
     * @memberof AuctionEntity
     */
    'status': AuctionEntityStatusEnum;
    /**
     * 
     * @type {LotEntity}
     * @memberof AuctionEntity
     */
    'lot': LotEntity;
    /**
     * 
     * @type {UserEntity}
     * @memberof AuctionEntity
     */
    'owner': UserEntity;
    /**
     * 
     * @type {UserEntity}
     * @memberof AuctionEntity
     */
    'winner'?: UserEntity;
    /**
     * 
     * @type {string}
     * @memberof AuctionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuctionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AuctionEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AuctionEntity
     */
    'deletedAt'?: string;
}

export const AuctionEntityStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED'
} as const;

export type AuctionEntityStatusEnum = typeof AuctionEntityStatusEnum[keyof typeof AuctionEntityStatusEnum];

/**
 * 
 * @export
 * @interface BidCreateDto
 */
export interface BidCreateDto {
    /**
     * Auction id
     * @type {string}
     * @memberof BidCreateDto
     */
    'auctionId': string;
    /**
     * Price of the bid
     * @type {number}
     * @memberof BidCreateDto
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface BidEntity
 */
export interface BidEntity {
    /**
     * Price of the bid
     * @type {number}
     * @memberof BidEntity
     */
    'price': number;
    /**
     * 
     * @type {AuctionEntity}
     * @memberof BidEntity
     */
    'auction': AuctionEntity;
    /**
     * 
     * @type {UserEntity}
     * @memberof BidEntity
     */
    'bidder': UserEntity;
    /**
     * Status of the bid
     * @type {string}
     * @memberof BidEntity
     */
    'status': BidEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BidEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BidEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BidEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof BidEntity
     */
    'deletedAt'?: string;
}

export const BidEntityStatusEnum = {
    Active: 'ACTIVE',
    Lost: 'LOST',
    Won: 'WON'
} as const;

export type BidEntityStatusEnum = typeof BidEntityStatusEnum[keyof typeof BidEntityStatusEnum];

/**
 * 
 * @export
 * @interface BidUpdateDto
 */
export interface BidUpdateDto {
    /**
     * Bid id
     * @type {string}
     * @memberof BidUpdateDto
     */
    'id': string;
    /**
     * Price of the bid
     * @type {number}
     * @memberof BidUpdateDto
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface FileStoreEntity
 */
export interface FileStoreEntity {
    /**
     * Original file name with extension. \"image.jpg\", \"document.pdf\", etc.
     * @type {string}
     * @memberof FileStoreEntity
     */
    'name': string;
    /**
     * File description if needed.
     * @type {string}
     * @memberof FileStoreEntity
     */
    'description'?: string;
    /**
     * File extension with dot. \".jpg\", \".png\", \".pdf\", etc.
     * @type {string}
     * @memberof FileStoreEntity
     */
    'ext': string;
    /**
     * File URL to get this file from current backend. Starts with \"/\".
     * @type {string}
     * @memberof FileStoreEntity
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileStoreEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FileStoreEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FileStoreEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FileStoreEntity
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface ImageStoreEntity
 */
export interface ImageStoreEntity {
    /**
     * Image width in pixels after resizing.
     * @type {number}
     * @memberof ImageStoreEntity
     */
    'width'?: number;
    /**
     * Image height in pixels after resizing.
     * @type {number}
     * @memberof ImageStoreEntity
     */
    'height'?: number;
    /**
     * URL to view this image, starts with \"/\".
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'url'?: string;
    /**
     * URL to download this image, starts with \"/\".
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'downloadUrl'?: string;
    /**
     * URL to view AVATAR of this image, starts with \"/\".
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'avatarUrl'?: string;
    /**
     * Is image visible to users.
     * @type {boolean}
     * @memberof ImageStoreEntity
     */
    'isVisible': boolean;
    /**
     * Original file name with extension. \"image.jpg\", \"document.pdf\", etc.
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'name': string;
    /**
     * File description if needed.
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'description'?: string;
    /**
     * File extension with dot. \".jpg\", \".png\", \".pdf\", etc.
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'ext': string;
    /**
     * 
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageStoreEntity
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * Login email
     * @type {string}
     * @memberof LoginDto
     */
    'login': string;
    /**
     * User password
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LotEntity
 */
export interface LotEntity {
    /**
     * Name of the lot
     * @type {string}
     * @memberof LotEntity
     */
    'name': string;
    /**
     * Description of the lot
     * @type {string}
     * @memberof LotEntity
     */
    'description'?: string;
    /**
     * 
     * @type {UserEntity}
     * @memberof LotEntity
     */
    'owner': UserEntity;
    /**
     * Image of the lot
     * @type {Array<ImageStoreEntity>}
     * @memberof LotEntity
     */
    'images': Array<ImageStoreEntity>;
    /**
     * 
     * @type {string}
     * @memberof LotEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LotEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LotEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LotEntity
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface LotFilterDto
 */
export interface LotFilterDto {
    /**
     * Owner id
     * @type {string}
     * @memberof LotFilterDto
     */
    'ownerId'?: string;
    /**
     * Sorting (orderBy)
     * @type {string}
     * @memberof LotFilterDto
     */
    'sort'?: string;
    /**
     * Skip
     * @type {number}
     * @memberof LotFilterDto
     */
    'skip'?: number;
    /**
     * Take
     * @type {number}
     * @memberof LotFilterDto
     */
    'take'?: number;
}
/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * User email.
     * @type {string}
     * @memberof UserEntity
     */
    'email': string;
    /**
     * User role.
     * @type {string}
     * @memberof UserEntity
     */
    'role': UserEntityRoleEnum;
    /**
     * User balance.
     * @type {number}
     * @memberof UserEntity
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'deletedAt'?: string;
}

export const UserEntityRoleEnum = {
    Admin: 'Admin',
    Manager: 'Manager'
} as const;

export type UserEntityRoleEnum = typeof UserEntityRoleEnum[keyof typeof UserEntityRoleEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Decide auction winner
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionControllerDecideAuctionWinner: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('auctionControllerDecideAuctionWinner', 'id', id)
            const localVarPath = `/auction/{id}/decide-winner`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get auction by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionControllerGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('auctionControllerGetById', 'id', id)
            const localVarPath = `/auction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe to auction updates
         * @summary 
         * @param {string} auctionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionControllerSubscribe: async (auctionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'auctionId' is not null or undefined
            assertParamExists('auctionControllerSubscribe', 'auctionId', auctionId)
            const localVarPath = `/auction/subscribe/{auctionId}`
                .replace(`{${"auctionId"}}`, encodeURIComponent(String(auctionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Auth by remote service and upsert user in database. If remote service not available -> auth by database.
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginByPassword: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLoginByPassword', 'loginDto', loginDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout and invalidate all previously created JWTs.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a bid
         * @summary 
         * @param {BidCreateDto} bidCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bidControllerBidCreate: async (bidCreateDto: BidCreateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bidCreateDto' is not null or undefined
            assertParamExists('bidControllerBidCreate', 'bidCreateDto', bidCreateDto)
            const localVarPath = `/bid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a bid
         * @summary 
         * @param {BidUpdateDto} bidUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bidControllerBidUpdate: async (bidUpdateDto: BidUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bidUpdateDto' is not null or undefined
            assertParamExists('bidControllerBidUpdate', 'bidUpdateDto', bidUpdateDto)
            const localVarPath = `/bid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a file.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerFileGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesControllerFileGet', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerFileUpload: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View an avatar.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerAvatarGet: async (imageName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('imageControllerAvatarGet', 'imageName', imageName)
            const localVarPath = `/images/avatar/{imageName}`
                .replace(`{${"imageName"}}`, encodeURIComponent(String(imageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download an image.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerImageDownload: async (imageName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('imageControllerImageDownload', 'imageName', imageName)
            const localVarPath = `/images/{imageName}`
                .replace(`{${"imageName"}}`, encodeURIComponent(String(imageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an image, avatar creates automatically.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerImageUpload: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View an image.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerImageView: async (imageName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('imageControllerImageView', 'imageName', imageName)
            const localVarPath = `/images/image/{imageName}`
                .replace(`{${"imageName"}}`, encodeURIComponent(String(imageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an image.
         * @summary 
         * @param {string} imageName 
         * @param {string} angle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerUpdateImage: async (imageName: string, angle: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('imageControllerUpdateImage', 'imageName', imageName)
            // verify required parameter 'angle' is not null or undefined
            assertParamExists('imageControllerUpdateImage', 'angle', angle)
            const localVarPath = `/images/update/{imageName}/{angle}`
                .replace(`{${"imageName"}}`, encodeURIComponent(String(imageName)))
                .replace(`{${"angle"}}`, encodeURIComponent(String(angle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a lot
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotCreate: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('lotControllerLotCreate', 'body', body)
            const localVarPath = `/lot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a lot
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lotControllerLotDelete', 'id', id)
            const localVarPath = `/lot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a lot by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lotControllerLotGetById', 'id', id)
            const localVarPath = `/lot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get filtered lots
         * @summary 
         * @param {LotFilterDto} lotFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotGetFiltered: async (lotFilterDto: LotFilterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lotFilterDto' is not null or undefined
            assertParamExists('lotControllerLotGetFiltered', 'lotFilterDto', lotFilterDto)
            const localVarPath = `/lot/filtered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lotFilterDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a lot
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotUpdate: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('lotControllerLotUpdate', 'body', body)
            const localVarPath = `/lot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current authorized user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUserCurrent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/user-current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Decide auction winner
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionControllerDecideAuctionWinner(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auctionControllerDecideAuctionWinner(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.auctionControllerDecideAuctionWinner']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get auction by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionControllerGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuctionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auctionControllerGetById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.auctionControllerGetById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Subscribe to auction updates
         * @summary 
         * @param {string} auctionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionControllerSubscribe(auctionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auctionControllerSubscribe(auctionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.auctionControllerSubscribe']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Auth by remote service and upsert user in database. If remote service not available -> auth by database.
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginByPassword(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginByPassword(loginDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.authControllerLoginByPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Logout and invalidate all previously created JWTs.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.authControllerLogout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a bid
         * @summary 
         * @param {BidCreateDto} bidCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bidControllerBidCreate(bidCreateDto: BidCreateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bidControllerBidCreate(bidCreateDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.bidControllerBidCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a bid
         * @summary 
         * @param {BidUpdateDto} bidUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bidControllerBidUpdate(bidUpdateDto: BidUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bidControllerBidUpdate(bidUpdateDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.bidControllerBidUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Download a file.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerFileGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerFileGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.filesControllerFileGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Upload a file.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerFileUpload(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileStoreEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerFileUpload(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.filesControllerFileUpload']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * View an avatar.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerAvatarGet(imageName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerAvatarGet(imageName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.imageControllerAvatarGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Download an image.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerImageDownload(imageName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerImageDownload(imageName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.imageControllerImageDownload']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Upload an image, avatar creates automatically.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerImageUpload(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageStoreEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerImageUpload(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.imageControllerImageUpload']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * View an image.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerImageView(imageName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerImageView(imageName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.imageControllerImageView']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an image.
         * @summary 
         * @param {string} imageName 
         * @param {string} angle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerUpdateImage(imageName: string, angle: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageStoreEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerUpdateImage(imageName, angle, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.imageControllerUpdateImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a lot
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lotControllerLotCreate(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LotEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lotControllerLotCreate(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lotControllerLotCreate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a lot
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lotControllerLotDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lotControllerLotDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lotControllerLotDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a lot by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lotControllerLotGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LotEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lotControllerLotGetById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lotControllerLotGetById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get filtered lots
         * @summary 
         * @param {LotFilterDto} lotFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lotControllerLotGetFiltered(lotFilterDto: LotFilterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LotEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lotControllerLotGetFiltered(lotFilterDto, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lotControllerLotGetFiltered']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a lot
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lotControllerLotUpdate(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LotEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lotControllerLotUpdate(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lotControllerLotUpdate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get current authorized user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUserCurrent(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUserCurrent(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.userControllerUserCurrent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Decide auction winner
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionControllerDecideAuctionWinner(id: string, options?: any): AxiosPromise<AuctionEntity> {
            return localVarFp.auctionControllerDecideAuctionWinner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get auction by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionControllerGetById(id: string, options?: any): AxiosPromise<AuctionEntity> {
            return localVarFp.auctionControllerGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe to auction updates
         * @summary 
         * @param {string} auctionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionControllerSubscribe(auctionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.auctionControllerSubscribe(auctionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Auth by remote service and upsert user in database. If remote service not available -> auth by database.
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginByPassword(loginDto: LoginDto, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerLoginByPassword(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout and invalidate all previously created JWTs.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: any): AxiosPromise<boolean> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a bid
         * @summary 
         * @param {BidCreateDto} bidCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bidControllerBidCreate(bidCreateDto: BidCreateDto, options?: any): AxiosPromise<BidEntity> {
            return localVarFp.bidControllerBidCreate(bidCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a bid
         * @summary 
         * @param {BidUpdateDto} bidUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bidControllerBidUpdate(bidUpdateDto: BidUpdateDto, options?: any): AxiosPromise<BidEntity> {
            return localVarFp.bidControllerBidUpdate(bidUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a file.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerFileGet(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.filesControllerFileGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerFileUpload(options?: any): AxiosPromise<FileStoreEntity> {
            return localVarFp.filesControllerFileUpload(options).then((request) => request(axios, basePath));
        },
        /**
         * View an avatar.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerAvatarGet(imageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerAvatarGet(imageName, options).then((request) => request(axios, basePath));
        },
        /**
         * Download an image.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerImageDownload(imageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerImageDownload(imageName, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload an image, avatar creates automatically.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerImageUpload(options?: any): AxiosPromise<ImageStoreEntity> {
            return localVarFp.imageControllerImageUpload(options).then((request) => request(axios, basePath));
        },
        /**
         * View an image.
         * @summary 
         * @param {string} imageName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerImageView(imageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerImageView(imageName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an image.
         * @summary 
         * @param {string} imageName 
         * @param {string} angle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerUpdateImage(imageName: string, angle: string, options?: any): AxiosPromise<ImageStoreEntity> {
            return localVarFp.imageControllerUpdateImage(imageName, angle, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a lot
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotCreate(body: object, options?: any): AxiosPromise<LotEntity> {
            return localVarFp.lotControllerLotCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a lot
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotDelete(id: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.lotControllerLotDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a lot by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotGetById(id: string, options?: any): AxiosPromise<LotEntity> {
            return localVarFp.lotControllerLotGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get filtered lots
         * @summary 
         * @param {LotFilterDto} lotFilterDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotGetFiltered(lotFilterDto: LotFilterDto, options?: any): AxiosPromise<Array<LotEntity>> {
            return localVarFp.lotControllerLotGetFiltered(lotFilterDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a lot
         * @summary 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lotControllerLotUpdate(body: object, options?: any): AxiosPromise<LotEntity> {
            return localVarFp.lotControllerLotUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current authorized user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUserCurrent(options?: any): AxiosPromise<UserEntity> {
            return localVarFp.userControllerUserCurrent(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Decide auction winner
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public auctionControllerDecideAuctionWinner(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).auctionControllerDecideAuctionWinner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get auction by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public auctionControllerGetById(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).auctionControllerGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe to auction updates
     * @summary 
     * @param {string} auctionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public auctionControllerSubscribe(auctionId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).auctionControllerSubscribe(auctionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Auth by remote service and upsert user in database. If remote service not available -> auth by database.
     * @summary 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authControllerLoginByPassword(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authControllerLoginByPassword(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout and invalidate all previously created JWTs.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a bid
     * @summary 
     * @param {BidCreateDto} bidCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bidControllerBidCreate(bidCreateDto: BidCreateDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bidControllerBidCreate(bidCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a bid
     * @summary 
     * @param {BidUpdateDto} bidUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bidControllerBidUpdate(bidUpdateDto: BidUpdateDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bidControllerBidUpdate(bidUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a file.
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public filesControllerFileGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).filesControllerFileGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public filesControllerFileUpload(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).filesControllerFileUpload(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View an avatar.
     * @summary 
     * @param {string} imageName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public imageControllerAvatarGet(imageName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).imageControllerAvatarGet(imageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download an image.
     * @summary 
     * @param {string} imageName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public imageControllerImageDownload(imageName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).imageControllerImageDownload(imageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload an image, avatar creates automatically.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public imageControllerImageUpload(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).imageControllerImageUpload(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View an image.
     * @summary 
     * @param {string} imageName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public imageControllerImageView(imageName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).imageControllerImageView(imageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an image.
     * @summary 
     * @param {string} imageName 
     * @param {string} angle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public imageControllerUpdateImage(imageName: string, angle: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).imageControllerUpdateImage(imageName, angle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a lot
     * @summary 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lotControllerLotCreate(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lotControllerLotCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a lot
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lotControllerLotDelete(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lotControllerLotDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a lot by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lotControllerLotGetById(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lotControllerLotGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get filtered lots
     * @summary 
     * @param {LotFilterDto} lotFilterDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lotControllerLotGetFiltered(lotFilterDto: LotFilterDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lotControllerLotGetFiltered(lotFilterDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a lot
     * @summary 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lotControllerLotUpdate(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lotControllerLotUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current authorized user
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userControllerUserCurrent(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userControllerUserCurrent(options).then((request) => request(this.axios, this.basePath));
    }
}



